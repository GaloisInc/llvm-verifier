This directory contains executables and support files for the LLVM
Symbolic Simulator (lss).

CONTENTS (Version 0.2c July 2013)

doc/           : lss man page
tutorial/      : Tutorials on using lss
bin/           : Command-line executables
test-programs/ : libgcrypt example code and proof scripts

NEW IN THIS RELEASE

- There is a new word-level backend that can be invoked by passing "-b saw"
  to the lss.  The backend allows SMTLIB export, but is only lightly
  tested.
- There is a new interactive debugger that can be accessed by passing
  "--startdebugger" to lss or pressing Ctrl-C during execution.

Bug fixes:

- There was a bug in handling of phi instructions that resulted in
  incorrect execution.  This manifested itself when compiling with
  optimization.


KNOWN ISSUES, LIMITATIONS, AND QUIRKS

Lightly tested:

- Execution of code generated with -m32 (or on 32 bit architectures); we suspect
  that there will be a few small tweaks needed to fully support this (sanity
  check parsed target data, implement additional intrinsic forms, etc.).
- llvm-optimized versions of our test codes (may expose missing
  instruction/intrinsic support)
- SMTLib generation.

Nonexistent, limited, or untested support for:

- We currently generate safety checks during simulation, but do not offer
  a facility for exporting them to AIGs or SMTLIB.  This means that code
  may be able to be "verified", but actually contains memory errors or other
  bugs.
- Codes compiled from C++
- Some vector instructions
- Exception handling (including setjmp/longjmp-style exception handling)
- clang and gcc builtins that can show up in compiled codes; we do not have
  implementations of these yet, and so cannot support them.  A short-term
  workaround is for the user to provide small implementations of these in C and
  link them into the final program executed by lss.
- LLVM intrinsics other than:
  - llvm.expecti32/64
  - llvm.lifetime.start
  - llvm.lifetime.end
  - llvm.memcpy.p0i8.p0i8.i32/64
  - llvm.memset.p0i8.i32/64
  - llvm.uadd.with.overflow.i16/32/64
  - llvm.objectsizei32/64
- User-definable memory segmentation
- Big-endian architectures
- Non-x86 architectures