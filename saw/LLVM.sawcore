module LLVM where 

import Prelude;

data LLVMType :: sort 0 where {
    -- Primitive types that we support.
    IntType :: (n :: Nat) -> LLVMType;
    FloatType  :: LLVMType;
    DoubleType :: LLVMType;
    -- | Nat is the width of the pointer in bytes.
    PtrType :: Nat -> LLVMType;
    -- Type for arrays.
    ArrayType :: (n :: Nat) -> LLVMType -> LLVMType;
    -- Type for structs.  The vector contains the type of each field, followed
    -- by the amount of padding to add after the field.
    StructType :: (n :: Nat) -> Vec n #(LLVMType,Nat) -> LLVMType;

    VectorType :: (n :: Nat) -> LLVMType -> LLVMType;
  }

mkIntType :: Nat -> LLVMType;
mkIntType n = IntType n;

mkFloatType :: LLVMType;
mkFloatType = FloatType;

mkDoubleType :: LLVMType;
mkDoubleType = FloatType;

mkPtrType :: Nat -> LLVMType;
mkPtrType n = PtrType n;

mkArrayType :: Nat -> LLVMType -> LLVMType;
mkArrayType n t = ArrayType n t;

mkValue :: (a :: sort 0) -> String -> a;

fieldType :: sort 0;
fieldType = #(LLVMType,Nat); 

emptyFields :: Vec 0 fieldType;
emptyFields = EmptyVec fieldType;

consFieldType :: fieldType -> (n::Nat) -> Vec n fieldType -> Vec (Succ n) fieldType;
consFieldType tp n r = ConsVec fieldType tp n r;

-- | Recuresive data struture for storing fields.
data StructValue :: (n :: Nat) -> Vec n fieldType -> sort 0 where {
    EmptyStruct :: StructValue 0 (EmptyVec fieldType);
    ConsStruct :: (tp :: LLVMType) 
               -> (padding :: Nat)
               -> (n :: Nat)
               -> (r :: Vec n fieldType)
               -> value tp
               -> StructValue n r
               -> StructValue (Succ n) (ConsVec fieldType (tp,padding) n r);
  }

value :: LLVMType -> sort 0;
value (IntType w) = bitvector w;
value FloatType   = Float;
value DoubleType  = Double;
value (PtrType n)   = bitvector (mulNat 8 n);
value (ArrayType n tp) = Vec n (value tp);
value (StructType n tps) = StructValue n tps;
value (VectorType n tp) = Vec n (value tp);

binFn :: sort 0 -> sort 0;
binFn tp = tp -> tp -> tp;

-- | Returns value in integer value as a natural number less than 2^w.
llvmIntValueNat :: (w :: Nat) -> bitvector w -> Nat;
llvmIntValueNat = bvToNat;

llvmIntConstant :: (w :: Nat) -> Nat -> bitvector w;
llvmIntConstant = bvNat;

bvVecZipWith :: ((w :: Nat) -> binFn (bitvector w))
             -> (n w :: Nat) 
             -> binFn (Vec n (bitvector w));
bvVecZipWith f n w = vZipWith (bitvector w) (bitvector w) (bitvector w) (f w) n; 

sbvVecZipWith :: ((w :: Nat) -> binFn (bitvector (Succ w)))
              -> (n w :: Nat) 
              -> binFn (Vec n (bitvector (Succ w)));
sbvVecZipWith f n w =
  vZipWith (bitvector (Succ w)) (bitvector (Succ w)) (bitvector (Succ w)) (f w) n; 

llvmAdd  :: (w :: Nat) -> binFn (bitvector w);
llvmAdd = bvAdd;

llvmAddV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmAddV = bvVecZipWith bvAdd;

llvmSub  :: (w :: Nat) -> binFn (bitvector w);
llvmSub = bvSub;

llvmSubV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmSubV = bvVecZipWith bvSub;

llvmMul  :: (w :: Nat) -> binFn (bitvector w);
llvmMul = bvMul;

llvmMulV :: (n w :: Nat) -> binFn (value (VectorType n (IntType w)));
llvmMulV = bvVecZipWith bvMul;

llvmUDiv  :: (w :: Nat) -> binFn (bitvector w);
llvmUDiv = bvUDiv;

llvmUDivV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmUDivV = bvVecZipWith bvUDiv;

llvmURem  :: (w :: Nat) -> binFn (bitvector w);
llvmURem = bvURem;

llvmURemV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmURemV = bvVecZipWith bvURem;

llvmSDiv  :: (w :: Nat) -> binFn (bitvector (Succ w));
llvmSDiv = bvSDiv;

llvmSDivV :: (n w :: Nat) -> binFn (Vec n (bitvector (Succ w)));
llvmSDivV = sbvVecZipWith bvSDiv;

llvmSRem  :: (w :: Nat)   -> binFn (bitvector (Succ w));
llvmSRem = bvSRem;

llvmSRemV :: (n w :: Nat) -> binFn (Vec n (bitvector (Succ w)));
llvmSRemV = sbvVecZipWith bvSRem;


llvmShl  :: (w :: Nat) -> binFn (bitvector w);
llvmShl w x y = bvShl w x (bvToNat w y);

llvmShlV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmShlV = bvVecZipWith llvmShl;

llvmLShr  :: (w :: Nat)   -> binFn (bitvector w);
llvmLShr w x y = bvShr w x (bvToNat w y);

llvmLShrV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmLShrV = bvVecZipWith llvmLShr;

llvmAShr  :: (w :: Nat) -> binFn (bitvector (Succ w));
llvmAShr w x y = bvSShr w x (bvToNat (Succ w) y);

llvmAShrV :: (n w :: Nat) -> binFn (Vec n (bitvector (Succ w)));
llvmAShrV = sbvVecZipWith llvmAShr;

llvmAnd  :: (w :: Nat)   -> binFn (bitvector w);
llvmAnd = bvAnd;

llvmAndV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmAndV = bvVecZipWith bvAnd;

llvmOr   :: (w :: Nat)   -> binFn (bitvector w);
llvmOr = bvOr;

llvmOrV  :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmOrV = bvVecZipWith bvOr;

llvmXor  :: (w :: Nat)   -> binFn (bitvector w);
llvmXor = bvXor;

llvmXorV :: (n w :: Nat) -> binFn (Vec n (bitvector w));
llvmXorV = bvVecZipWith bvXor;

singleField :: LLVMType -> Nat -> Vec 1 fieldType;
singleField tp p = consFieldType (tp,p) 0 emptyFields;

arithmeticWithOverflowResult :: Nat -> Nat -> Nat -> LLVMType;
arithmeticWithOverflowResult w p1 p2 =
  StructType 2 (consFieldType (IntType w,p1) 1
               (singleField (IntType 1) p2));

mkOverflowResult :: (w p1 p2 :: Nat)
                 -> #(Bool, bitvector w)
                 -> value (arithmeticWithOverflowResult w p1 p2);
mkOverflowResult w p1 p2 (c,z) = 
  ConsStruct (IntType w) p1 1 (singleField (IntType 1) p2) z
    (ConsStruct (IntType 1) p2 0 emptyFields [c] EmptyStruct);            

-- Width of bitvectors, amount of padding for first and second fields.
llvmAddWithOverflow :: (w p1 p2 :: Nat) 
                    -> bitvector w
                    -> bitvector w
                    -> value (arithmeticWithOverflowResult w p1 p2);
llvmAddWithOverflow w p1 p2 x y =
  mkOverflowResult w p1 p2 (bvAddWithCarry w x y);

binRel :: sort 0 -> sort 0;
binRel tp = tp -> tp -> bitvector 1;

binVRel :: Nat -> sort 0 -> sort 0;
binVRel n tp = Vec n tp -> Vec n tp -> Vec n (bitvector 1);

liftBVRel :: ((w :: Nat) -> bitvector w -> bitvector w -> Bool)
          -> (w :: Nat) -> binRel (bitvector w);
liftBVRel f w x y = ite (bitvector 1) (f w x y) (bvNat 1 1) (bvNat 1 0);


liftSBVRel :: ((w :: Nat) -> bitvector (Succ w) -> bitvector (Succ w) -> Bool)
          -> (w :: Nat) -> binRel (bitvector (Succ w));
liftSBVRel f w x y = ite (bitvector 1) (f w x y) (bvNat 1 1) (bvNat 1 0);

liftVecBVRel :: ((w :: Nat) -> bitvector w -> bitvector w -> Bool)
             -> (n w :: Nat)
             -> binVRel n (bitvector w);
liftVecBVRel f n w =
  vZipWith (bitvector w)
           (bitvector w)
           (bitvector 1)
           (liftBVRel f w)
           n;

liftVecSBVRel :: ((w :: Nat) -> bitvector (Succ w) -> bitvector (Succ w) -> Bool)
              -> (n w :: Nat)
              -> binVRel n (bitvector (Succ w));
liftVecSBVRel f n w =
  vZipWith (bitvector (Succ w))
           (bitvector (Succ w))
           (bitvector 1)
           (liftSBVRel f w)
           n;


llvmIeqBool :: (w :: Nat) -> bitvector w -> bitvector w -> Bool;
llvmIeqBool = bvEq;

llvmIuleBool :: (w :: Nat) -> bitvector w -> bitvector w -> Bool;
llvmIuleBool = bvule;

llvmIeq llvmIne :: (w :: Nat)   -> binRel (bitvector w);
llvmIeq = liftBVRel bvEq;
llvmIne = liftBVRel bvNe;

llvmIeqV llvmIneV :: (n w :: Nat) -> binVRel n (bitvector w);
llvmIeqV = liftVecBVRel bvEq;
llvmIneV = liftVecBVRel bvNe;

llvmIugt llvmIuge llvmIult llvmIule :: (w :: Nat)   -> binRel (bitvector w);
llvmIugt = liftBVRel bvugt;
llvmIuge = liftBVRel bvuge;
llvmIult = liftBVRel bvult;
llvmIule = liftBVRel bvule;

llvmIugtV llvmIugeV llvmIultV llvmIuleV :: (n w :: Nat) -> binVRel n (bitvector w);
llvmIugtV = liftVecBVRel bvugt;
llvmIugeV = liftVecBVRel bvuge;
llvmIultV = liftVecBVRel bvult;
llvmIuleV = liftVecBVRel bvule;

llvmIsgt  llvmIsge  llvmIslt  llvmIsle  :: (w :: Nat)   -> binRel (bitvector (Succ w));
llvmIsgt = liftSBVRel bvsgt;
llvmIsge = liftSBVRel bvsge;
llvmIslt = liftSBVRel bvslt;
llvmIsle = liftSBVRel bvsle;

llvmIsgtV llvmIsgeV llvmIsltV llvmIsleV :: (n w :: Nat) -> binVRel n (bitvector (Succ w));
llvmIsgtV = liftVecSBVRel bvsgt;
llvmIsgeV = liftVecSBVRel bvsge;
llvmIsltV = liftVecSBVRel bvslt;
llvmIsleV = liftVecSBVRel bvsle;
--TODO

-- | Defines a function that maps array elements from one range to another.
bvMap :: (x y :: Nat)
      -> (bitvector x -> bitvector y)
      -> (n :: Nat) -> Vec n (bitvector x) -> Vec n (bitvector y);
bvMap x y = vMap (bitvector x) (bitvector y);

llvmTrunc :: (d r :: Nat) -> bitvector (addNat r d) -> bitvector r;
llvmTrunc = bvTrunc;

llvmTruncV :: (n d r :: Nat) -> Vec n (bitvector (addNat r d)) -> Vec n (bitvector r);
llvmTruncV n d r = bvMap (addNat r d) r (bvTrunc d r) n;

llvmZExt  :: (d i :: Nat)   -> bitvector i -> bitvector (addNat i d);
llvmZExt = bvUExt;

llvmZExtV :: (n d i :: Nat) -> Vec n (bitvector i) -> Vec n (bitvector (addNat i d));
llvmZExtV n d i = bvMap i (addNat i d) (bvUExt d i) n;

llvmSExt  :: (d i :: Nat)   -> bitvector (Succ i) -> bitvector (addNat (Succ i) d);
llvmSExt = bvSExt;

llvmSExtV :: (n d i :: Nat)
          -> Vec n (bitvector (Succ i))
          -> Vec n (bitvector (addNat (Succ i) d));
llvmSExtV n d i = bvMap (Succ i) (addNat (Succ i) d) (bvSExt d i) n;

llvmSelect  :: (tp :: LLVMType) -> bitvector 1 -> value tp -> value tp -> value tp;
llvmSelect tp c = ite (value tp) (get 1 Bool c (FinVal 0 0));

llvmSelectV :: (n :: Nat)
            -> (tp :: LLVMType)
            -> Vec n (bitvector 1)
            -> Vec n (value tp)
            -> Vec n (value tp)
            -> Vec n (value tp);
llvmSelectV n tp c x y = 
  generate n (value tp) (\(i :: Fin n) -> llvmSelect tp (get n (bitvector 1) c i)
                                                        (get n (value tp) x i)
                                                        (get n (value tp) y i));

llvmStructElt :: (n :: Nat)
              -> (tps :: Vec n fieldType)
              -> StructValue n tps
              -> (i :: Fin n)
              -> value (fst LLVMType Nat (get n fieldType tps i));
llvmStructElt _ _ (ConsStruct _ _ _ _ v _) (FinVal Zero _) = v;
llvmStructElt _ (ConsVec _ _ _ v) (ConsStruct _ _ _ _ _ r) (FinVal (Succ i) j) =
  llvmStructElt (Succ (addNat i j)) v r (FinVal i j);

llvmArrayElt :: (n :: Nat)
             -> (tp :: LLVMType)
             -> Vec n (value tp)
             -> Fin n
             -> value tp;
llvmArrayElt n tp = get n (value tp);

-- | Append the one bitvector to another.  The first vector is the most significant.
llvmAppendInt :: (u v :: Nat)
              -> bitvector u
              -> bitvector v
              -> bitvector (addNat v u);
llvmAppendInt m n x y = append n m Bool y x;

-- | @llvmIntSlice i n o v@ returns an @n@-bit bitvector equal to v / 2^i.
llvmIntSlice :: (i n o :: Nat) -> bitvector (addNat (addNat i n) o) -> bitvector n;
llvmIntSlice i n o a = vDrop Bool i n (vTake Bool (addNat i n) o a); 

llvmIntToFloat  :: bitvector 32 -> Float;
llvmIntToFloat = bvToFloat;

llvmFloatToInt  :: Float -> bitvector 32;
llvmFloatToInt = floatToBV;

llvmIntToDouble :: bitvector 64 -> Double;
llvmIntToDouble = bvToDouble;

llvmDoubleToInt :: Double -> bitvector 64;
llvmDoubleToInt = doubleToBV;

ite_same :: (a :: sort 1)
         -> (b :: Bool)
         -> (x :: a)
         -> Eq a (ite a b x x) x;


ite_false_false :: (b x :: Bool) -> Eq Bool (ite Bool b x False) (and b x);

and_true2 :: (b :: Bool) -> Eq Bool (and b True) b;

bvEq_commute_ite1 :: (w :: Nat)
                  -> (b :: Bool)
                  -> (x y z :: bitvector w)
                  -> Eq Bool
                        (bvEq w (ite (bitvector w) b x y) z)
                        (ite Bool b (bvEq w x z) (bvEq w y z));


-- These rules are unsound due to overflow:

bvule_sameL :: (n :: Nat)
            -> (x z :: bitvector n) 
            -> Eq Bool
                  (bvule n x (bvAdd n x z))
                  True;

bvule_sameR :: (n :: Nat)
            -> (x y :: bitvector n) 
            -> Eq Bool
                  (bvule n (bvAdd n x y) x)
                  (bvEq n y (bvNat n 0));

bvule_same2 :: (n :: Nat)
            -> (x y z :: bitvector n) 
            -> Eq Bool
                  (bvule n (bvAdd n x y) (bvAdd n x z))
                  (bvule n y z);
