{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS_GHC -O0 #-}
module Verifier.LLVM.Backend.SAW
  ( SAWBackend
  , SAWMemory
  , createSAWBackend
  , createSAWBackend'
  , llvmModule
  ) where

import Control.Applicative hiding (empty)
import Control.Exception (assert)
import Control.Lens hiding (op)
import Control.Monad
import Control.Monad.IO.Class (liftIO)
import qualified Data.AIG as AIG
import Data.Bits
import Data.IORef
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe
import Data.SBV.Dynamic
import Data.Set (Set)
import qualified Data.Set as Set
import qualified Data.Vector as V

import Verifier.SAW as SAW
import Verifier.SAW.Conversion
import Verifier.SAW.ParserUtils as SAW
import Verifier.SAW.Prelude
import qualified Verifier.SAW.Prim as Prim
import qualified Verifier.SAW.Recognizer as R
import Verifier.SAW.Rewriter
import qualified Verifier.SAW.Simulator.BitBlast as BB
import qualified Verifier.SAW.Simulator.SBV as SBVSim

import Verifier.LLVM.Backend as LLVM
import Verifier.LLVM.Codebase.AST
import qualified Verifier.LLVM.MemModel as MM


#if !MIN_VERSION_base(4,6,0)
-- | Strict version of modifyIORef
-- Added for compatibility with GHC base 4.5 and 4.6
modifyIORef' :: IORef a -> (a -> a) -> IO ()
modifyIORef' r f = do
  v <- readIORef r
  writeIORef r $! f v
#endif

preludeBVNatTermF :: TermF t
preludeBVNatTermF = FTermF $ GlobalDef (mkIdent preludeModuleName "bvNat")

scBitwidth :: SharedContext s -> BitWidth -> IO (SharedTerm s)
scBitwidth sc w = scNat sc (fromIntegral w)

asUnsignedBitvector :: BitWidth -> SharedTerm s -> Maybe Integer
asUnsignedBitvector w s2 = do
  (s1, vt) <- R.asApp s2
  (s0, wt) <- R.asApp s1
  when (unwrapTermF  s0 /= preludeBVNatTermF) Nothing
  when (R.asNatLit wt /= Just (fromIntegral w)) Nothing
  toInteger <$> R.asNatLit vt

asSignedBitvector :: BitWidth -> SharedTerm s -> Maybe Integer
asSignedBitvector w s2
    | w == 0 = error "Bad bitwidth"
    | otherwise = s2u <$> asUnsignedBitvector w s2
  where s2u v | v `testBit` (w-1) = v - 2^w
              | otherwise = v

scFloat :: SharedContext s -> Float -> IO (SharedTerm s)
scFloat sc v = scTermF sc (FTermF (FloatLit v))

scDouble :: SharedContext s -> Double -> IO (SharedTerm s)
scDouble sc v = scTermF sc (FTermF (DoubleLit v))

-- | Create a vector from a term representing its element types and the element.
scVecLit :: SharedContext s
         -> SharedTerm s -- ^ Type of vector elements.
         -> V.Vector (SharedTerm s) -- ^ Elements
         -> IO (SharedTerm s)
scVecLit sc tp v = scTermF sc (FTermF (ArrayValue tp v))

$(runDecWriter $ do
    prelude <- defineImport [|preludeModule|] preludeModule
    llvm <- defineModuleFromFile [prelude] "llvmModule" "saw/LLVM.sawcore"
    declareDefTermF prelude "ite"
    declareSharedModuleFns "LLVM" (decVal llvm)
 )

-- make the compiler stop complaining about autogenerated definitions
-- that we never reference
_ignoreUnused :: a
_ignoreUnused = undefined scApplyLLVM_llvmArrayElt scApplyLLVM_trunc31

scResizeTerm :: SharedContext s
             -> BitWidth -- ^ Input width
             -> (BitWidth, SharedTerm s) -- ^ Result bitwith and term representing it.
             -> SharedTerm s
             -> IO (SharedTerm s)
scResizeTerm sc iw (rw,rt) v
  | iw < rw = do
      fn <- scApplyLLVM_llvmZExt sc
      dt <- scBitwidth sc (rw - iw)
      fn dt rt v
  | iw > rw = do
      fn <- scApplyLLVM_llvmTrunc sc
      dt <- scBitwidth sc (iw - rw)
      fn dt rt v
  | otherwise = return v

-- | Create a bitvector from a constant.
scLLVMIntConst :: SharedContext s
                 -> BitWidth -- ^ Result width with corresponding term.
                 -> Integer -- ^ Value of bitvector.
                 -> IO (SharedTerm s)
scLLVMIntConst sc w v = do
  wt <- scBitwidth sc w
  scLLVMIntConst' sc (w,wt) v

-- | Create a bitvector from a constant.
scLLVMIntConst' :: SharedContext s
                -> (BitWidth, SharedTerm s) -- ^ Result width with corresponding term.
                -> Integer -- ^ Value of bitvector.
                -> IO (SharedTerm s)
scLLVMIntConst' sc (w,wt) v = do
  cfn <- scApplyLLVM_llvmIntConstant sc
  cfn wt =<< scNat sc (fromInteger (v `mod` 2^(toInteger w)))

{-
Essay on how allocations are done:

We represent the result of an allocation as a fresh variable.  Arithmetic
on terms with these variables is designed to normalize the term into the
form "Var + offset" where feasible.

There are implicit assumptions on disjoinness between allocations.


Operations that attempt to exploit this normalization include:
  Integer arithmetic add, sub.
  Pointer add.
  UAddWithOverflow.
  Integer comparison operations.
-}

scFreshPtr :: SharedContext s -> DataLayout -> IO (SharedTerm s)
scFreshPtr sc dl = do
  valueFn <- scApplyLLVM_value sc
  let w = ptrBitwidth dl
  scFreshGlobal sc "_" =<< valueFn =<< scIntType sc w

-- | Set of shared term variables that refer to allocations.
type SharedTermSetRef s = IORef (Set (SharedTerm s))

asApp2 :: SharedTerm s -> Maybe (SharedTerm s, SharedTerm s, SharedTerm s)
asApp2 t = do
  (t1,a2) <- R.asApp t
  (t0,a1) <- R.asApp t1
  return (t0,a1,a2)

data SAWBackendState t
   = SBS { sbsDataLayout :: DataLayout
         , sbsContext :: SharedContext t
           -- | Stores list of fresh variables and their associated terms with
           -- most recently allocated variables first.
         , sbsVars :: IORef [(BitWidth,VarIndex,ExtCns (SharedTerm t))]
           -- | Allocations added.
         , sbsAllocations :: SharedTermSetRef t
           -- | Width of pointers in bits as a nat.
         , sbsPtrWidth :: SharedTerm t
           -- | LLVM Type of a pointer
         , sbsPtrType    :: SharedTerm t
           -- | LLVM Type of floats.
         , sbsFloatType  :: SharedTerm t
           -- | LLVM Type for double
         , sbsDoubleType :: SharedTerm t
           -- | Creates LLVM type for arrays
         , sbsArrayTypeFn :: SharedTerm t -> SharedTerm t -> IO (SharedTerm t)
           -- | Creates LLVM type for vectors
         , sbsVecTypeFn :: SharedTerm t -> SharedTerm t -> IO (SharedTerm t)
           -- | Creates LLVM type for structs
         , sbsStructTypeFn :: SharedTerm t -> SharedTerm t -> IO (SharedTerm t)
           -- | Fieldtype constant
         , sbsFieldType :: SharedTerm t
         , sbsAdd :: BitWidth -> IO (SharedTerm t -> SharedTerm t -> IO (SharedTerm t))
         , sbsSub :: BitWidth -> IO (SharedTerm t -> SharedTerm t -> IO (SharedTerm t))
         , smGenerator :: MM.TermGenerator IO (SharedTerm t) (SharedTerm t) (SharedTerm t)
         }

data DecomposeResult s
   = BasePtr
   | OffsetPtr !(SharedTerm s) !(SharedTerm s)
   | SymbolicPtr

mkBackendState :: forall t
               .  DataLayout
               -> SharedContext t
               -> IO (SAWBackendState t)
mkBackendState dl sc = do
  vars <- newIORef []
  allocs <- newIORef Set.empty
  ptrWidth <- scBitwidth sc (ptrBitwidth dl)
  addFn <- scApplyLLVM_llvmAdd sc

  subFn <- scApplyLLVM_llvmSub sc

  -- LLVM Type imports
  ptrType <- join $ scApplyLLVM_PtrType sc <*> scNat sc (fromIntegral (dl^.ptrSize))
  llvmFloatType  <- scApplyLLVM_FloatType sc
  llvmDoubleType <- scApplyLLVM_DoubleType sc
  arrayTypeFn  <- scApplyLLVM_ArrayType sc
  vecTypeFn    <- scApplyLLVM_VectorType sc
  structTypeFn <- scApplyLLVM_StructType sc
  fieldType <- scApplyLLVM_fieldType sc

  trueTerm  <- scApplyPrelude_True  sc
  falseTerm <- scApplyPrelude_False sc

  ptrAddOp <- addFn ptrWidth
  let constPtr = scLLVMIntConst' sc (ptrBitwidth dl, ptrWidth)
  let decomposePtr ptr = do
        s <- readIORef allocs
        return $
          case asApp2 ptr of
            Just (f,b,o) | f == ptrAddOp ->
              if Set.member b s then OffsetPtr b o else SymbolicPtr
            _  | Set.member ptr s -> BasePtr
               | otherwise -> SymbolicPtr
  let ptrAdd x y = do
        mx <- decomposePtr x
        let addPrim = scApply2 sc ptrAddOp
        case mx of
          BasePtr -> addPrim x y
          OffsetPtr b o -> addPrim b =<< addPrim o y
          SymbolicPtr -> do
            my <- decomposePtr y
            case my of
              BasePtr -> addPrim y x
              OffsetPtr b o -> addPrim b =<< addPrim x o
              SymbolicPtr -> addPrim x y
  ptrSubOp <- subFn ptrWidth
  nullPtr <- constPtr 0
  let ptrSub x y = do
        mx <- decomposePtr x
        my <- decomposePtr y
        let subPrim = scApply2 sc ptrSubOp
        case (mx, my) of
          (BasePtr, BasePtr) | x == y -> return nullPtr
          (BasePtr, OffsetPtr by oy) | x == by -> subPrim nullPtr oy
          (OffsetPtr bx ox, BasePtr) | bx == y -> return ox
          (OffsetPtr bx ox, OffsetPtr by oy) | bx == by -> subPrim ox oy
          _ -> subPrim x y

  let decomposeOffset t = fmap toInteger <$> scIntAsConst' sc ptrWidth t

  muxOp <- scTermF sc iteTermF

  andFn <- scApplyPrelude_and sc
  orFn  <- scApplyPrelude_or  sc
  boolMuxOp <- join $ scApply sc muxOp <$> scPrelude_Bool sc
  intTypeFn <- scApplyLLVM_IntType sc
  let mkTypeTerm :: MM.Type -> IO (SharedTerm t)
      mkTypeTerm tp0 =
        case MM.typeF tp0 of
          MM.Bitvector n -> intTypeFn =<< scNat sc (8*fromIntegral n)
          MM.Float  -> return llvmFloatType
          MM.Double -> return llvmDoubleType
          MM.Array n tp -> join $ arrayTypeFn <$> scNat sc (fromIntegral n) <*> mkTypeTerm tp
          MM.Struct flds -> join $ structTypeFn
                              <$> scNat sc (fromIntegral (V.length flds))
                              <*> fieldVFn flds
      fieldFn :: MM.Field MM.Type -> IO (SharedTerm t, Nat)
      fieldFn f = (, fromIntegral (MM.fieldPad f)) <$> mkTypeTerm (f^.MM.fieldVal)
      fieldVFn flds = scFieldInfo sc fieldType =<< traverse fieldFn flds

  intToFloat  <- scApplyLLVM_llvmIntToFloat sc
  intToDouble <- scApplyLLVM_llvmIntToDouble sc

  ptrEqOp <- scApplyLLVM_llvmIeqBool  sc
  ptrLeOp <- scApplyLLVM_llvmIuleBool sc

  appendFn <- scApplyPrelude_append sc
  boolTy <- scBoolType sc
  let appendInt m n x y = appendFn m n boolTy x y
  sliceFn   <- scApplyLLVM_llvmIntSlice sc
  valueFn   <- scApplyLLVM_value sc
  let tg = MM.TG
              { MM.tgPtrWidth = dl^.ptrSize
              , MM.tgPtrDecompose = \ptr -> do
                  mr <- decomposePtr ptr
                  case mr of
                    BasePtr -> return $ MM.ConcreteOffset ptr 0
                    OffsetPtr b o -> do
                      mo <- decomposeOffset o
                      return $ case mo of
                                 Just o' -> MM.ConcreteOffset b o'
                                 Nothing -> MM.SymbolicOffset b o
                    SymbolicPtr -> return $ MM.Symbolic ptr
              , MM.tgPtrSizeDecompose = decomposeOffset
              , MM.tgConstPtr = constPtr . fromIntegral
              , MM.tgAddPtr = ptrAdd
              , MM.tgCheckedAddPtr = \x y -> (trueTerm,) <$> ptrAdd x y
              , MM.tgSubPtr = ptrSub

              , MM.tgTrue  = trueTerm
              , MM.tgFalse = falseTerm
              , MM.tgPtrEq = ptrEqOp ptrWidth
              , MM.tgPtrLe = ptrLeOp ptrWidth
              , MM.tgAnd   = andFn
              , MM.tgOr    = orFn
              , MM.tgMuxCond = scApply3 sc boolMuxOp

              , MM.tgConstBitvector = \w -> scLLVMIntConst sc (8*fromIntegral w)
              , MM.tgConstFloat  = scFloat sc
              , MM.tgConstDouble = scDouble sc
              , MM.tgApplyCtorF = \vcf ->
                 case vcf of
                   MM.ConcatBV xw x yw y -> do
                     xwt <- scNat sc $ fromIntegral xw `shiftL` 3
                     ywt <- scNat sc $ fromIntegral yw `shiftL` 3
                     case dl^.intLayout of
                       BigEndian    -> appendInt xwt ywt x y
                       LittleEndian -> appendInt ywt xwt y x
                   MM.BVToFloat x -> intToFloat x
                   MM.BVToDouble x -> intToDouble x
                   MM.ConsArray tp x n y -> do
                     consFn <- scApplyPrelude_ConsVec sc
                     tpt <- mkTypeTerm tp
                     nt <- scNat sc (fromInteger n)
                     consFn tpt x nt y
                   MM.AppendArray tp m x n y -> do
                     join $ appendFn <$> scNat sc (fromInteger m)
                                     <*> scNat sc (fromInteger n)
                                     <*> (valueFn =<< mkTypeTerm tp)
                                     ?? x
                                     ?? y
                   MM.MkArray tp v ->
                     join $ scVecLit sc <$> (valueFn =<< mkTypeTerm tp) ?? v
                   MM.MkStruct v -> do
                     ExprEvalFn eval <- createStructValue sc =<< (traverse . _1) fieldFn v
                     eval return
              , MM.tgApplyViewF = \vf -> do
                  let slice i n o v = do
                        join $ sliceFn
                                 <$> scNat sc (8*fromIntegral i)
                                 <*> scNat sc (8*fromIntegral n)
                                 <*> scNat sc (8*fromIntegral o)
                                 ?? v
                  case vf of
                    MM.SelectLowBV m n v -> do
                      case dl^.intLayout of
                        BigEndian    -> slice 0 m n v -- High order bits of v.
                        LittleEndian -> slice n m 0 v -- low order bits of v.
                    MM.SelectHighBV m n v -> do
                      case dl^.intLayout of
                        BigEndian    -> slice m n 0 v -- Low order bits of v.
                        LittleEndian -> slice 0 n m v -- High order bits of v.
                    MM.FloatToBV v  -> join $ scApplyLLVM_llvmFloatToInt sc ?? v
                    MM.DoubleToBV v -> join $ scApplyLLVM_llvmDoubleToInt sc ?? v
                    MM.ArrayElt n tp o v -> do
                      let n' = fromIntegral n
                          o' = fromIntegral o
                          -- w  = 64 -- TODO: don't hard-code size
                      join $ scApplyPrelude_at sc
                             <*> scNat sc n'
                             <*> (valueFn =<< mkTypeTerm tp)
                             <*> pure v
                             <*> scNat sc o'
                    MM.FieldVal tps i v -> do
                      let n = fromIntegral (V.length tps)
                      join $ scApplyLLVM_llvmStructElt sc
                               <*> scNat sc n
                               <*> fieldVFn tps
                               <*> pure v
                               <*> scFinConst sc (fromIntegral i) n
              , MM.tgMuxTerm = \c tp x y -> do
                  tpt <- join $ scApplyLLVM_value sc <*> mkTypeTerm tp
                  scApply4 sc muxOp tpt c x y
              }

  return SBS { sbsDataLayout = dl
             , sbsContext = sc
             , sbsVars    = vars
             , sbsAllocations  = allocs
             , sbsPtrWidth     = ptrWidth
             , sbsPtrType      = ptrType
             , sbsFloatType    = llvmFloatType
             , sbsDoubleType   = llvmDoubleType
             , sbsArrayTypeFn  = arrayTypeFn
             , sbsVecTypeFn    = vecTypeFn
             , sbsStructTypeFn = structTypeFn
             , sbsFieldType    = fieldType
             , sbsAdd = \w ->
                 if w == ptrBitwidth dl then
                   return ptrAdd
                 else do
                   op <- addFn =<< scBitwidth sc w
                   return $ scApply2 sc op
             , sbsSub = \w ->
                 if w == ptrBitwidth dl then
                   return ptrSub
                 else do
                   op <- subFn =<< scBitwidth sc w
                   return $ scApply2 sc op
             , smGenerator = tg
             }

-- | Attempt to parse the second term as a constant integer.
-- The first term is the width of the term.
scIntAsConst' :: SharedContext s -> SharedTerm s -> SharedTerm s -> IO (Maybe Nat)
scIntAsConst' sc w t =
  fmap R.asNatLit $ join $
    scApplyLLVM_llvmIntValueNat sc ?? w ?? t

type SAWMem s = MM.Mem (SharedTerm s) (SharedTerm s) (SharedTerm s)

data SAWMemory s = SAWMemory { _memSymbols :: Map (SharedTerm s) Symbol
                             , _memState :: MM.Mem (SharedTerm s) (SharedTerm s) (SharedTerm s)
                             }

emptySAWMemory :: SAWMemory s
emptySAWMemory = SAWMemory { _memSymbols = Map.empty
                           , _memState = MM.emptyMem
                           }

memSymbols :: Simple Lens (SAWMemory s) (Map (SharedTerm s) Symbol)
memSymbols = lens _memSymbols (\s v -> s { _memSymbols = v })

memState :: Simple Lens (SAWMemory s) (SAWMem s)
memState = lens _memState (\s v -> s { _memState = v })

smAddDefine :: DataLayout
            -> SharedContext s
            -> SAWMemory s
            -> Symbol
            -> [BlockLabel]
            -> IO (Maybe (SharedTerm s, [SharedTerm s], SAWMemory s))
smAddDefine dl sc m sym lbls = do
  symt <- scFreshPtr sc dl
  lblst <- traverse (\_ -> scFreshPtr sc dl) lbls
  let m' = m & memSymbols . at symt ?~ sym
  return $ Just (symt, lblst, m')

-- | Return symbol associated with address if any.
smLookupSymbol :: SAWMemory s -> SharedTerm s -> LookupSymbolResult
smLookupSymbol m t =
  case m^.memSymbols^.at t of
    Just r -> Right r
    Nothing -> Left Indeterminate

smAlloc :: SAWBackendState t
        -> MM.AllocType
        -> SAWMemory t
        -> MemType
        -> BitWidth -- ^ Width of count.
        -> SharedTerm t -- ^ Count
        -> Alignment
        -> IO (AllocResult (SAWBackend t))
smAlloc sbs atp m mtp w cnt _ = do
  let sc = sbsContext sbs
  -- Get size of tp in bytes.
  let dl = sbsDataLayout sbs
  let pw = ptrBitwidth dl
  let pwt = sbsPtrWidth sbs
  tpSize <- scLLVMIntConst' sc (pw,pwt) (toInteger (memTypeSize dl mtp))
  -- Convert count to have same bitwidth as pointer.
  cnt' <- scResizeTerm sc w (pw,pwt) cnt
  -- Get total number of bytes.
  mulFn <- scApplyLLVM_llvmMul sc
  mulOp <- mulFn pwt
  totalSize <- scApplyAll sc mulOp [cnt', tpSize]
  -- Get true predicate.
  t <- scApplyPrelude_True sc
  -- Return allocation.
  -- Create new variable for base address.
  base <- allocPtr sbs
  -- Return successful allocation.
  let m' = m & memState %~ MM.allocMem atp base totalSize
  return (AResult t base m')

allocPtr :: SAWBackendState t -> IO (SharedTerm t)
allocPtr sbs = do
  -- Create new variable for base address.
  s <- readIORef (sbsAllocations sbs)
  let nm = "$alloc" ++ show (Set.size s)
  let sc = sbsContext sbs
  tp <- join $ scApplyLLVM_value sc ?? sbsPtrType sbs
  base <- scFreshGlobal sc nm tp
  writeIORef (sbsAllocations sbs) $! Set.insert base s
  return base

mergeEq :: (Ord k, Eq a) => Map k a -> Map k a -> Map k a
mergeEq mx = Map.filterWithKey p
  where p k u = Map.lookup k mx == Just u

smMerge :: SharedTerm s -> SAWMemory s -> SAWMemory s -> SAWMemory s
smMerge c x y =
  SAWMemory { _memSymbols = mergeEq (x^.memSymbols) (y^.memSymbols)
            , _memState = MM.mergeMem c (x^.memState) (y^.memState)
            }

-- | Return term value, length of fields, and vector with the types of the fields.
sbsStructValue :: SAWBackendState t
               -> V.Vector (FieldInfo, v)
               -> IO (ExprEvalFn v (SharedTerm t))
sbsStructValue sbs flds = do
  let fn fi = do
         (,fromIntegral (fiPadding fi)) <$> sbsMemType sbs (fiType fi)
  createStructValue (sbsContext sbs) =<< (traverse . _1) fn flds

-- | Return term value, length of fields, and vector with the types of the fields.
createStructValue :: forall s v
                   . SharedContext s
                     -- For each field, provide type, number of padding bytes, and value.
                  -> V.Vector ((SharedTerm s, Nat), v)
                  -> IO (ExprEvalFn v (SharedTerm s))
createStructValue sc flds = do
  fieldType <- scApplyLLVM_fieldType sc
  let foldFn :: ((SharedTerm s, Nat), v)
             -> (Nat, ExprEvalFn v (SharedTerm s), SharedTerm s)
             -> IO (Nat, ExprEvalFn v (SharedTerm s), SharedTerm s)
      foldFn ((mtp,pad),expr) (n,ExprEvalFn reval, rvtp) = do
        nt <- scNat sc n
        padding <- scNat sc pad
        consStruct <- scApplyLLVM_ConsStruct sc
        let cfn = consStruct mtp padding nt rvtp
        let reval' = ExprEvalFn $ \eval ->
                      join $ ((liftIO .) . cfn) <$> eval expr <*> reval eval
        consVecFn <- scApplyPrelude_ConsVec sc
        entry <- scTuple sc [mtp,padding]
        (n+1,reval',) <$> consVecFn fieldType entry nt rvtp
  -- Get initial value and type.
  emptyStruct <- scApplyLLVM_EmptyStruct sc
  let eval0 = ExprEvalFn $ \_ -> return emptyStruct
  emptyFn <- scApplyPrelude_EmptyVec sc
  tp0 <- emptyFn fieldType
  view _2 <$> foldrMOf folded foldFn (0, eval0, tp0) flds

scApply2 :: SharedContext s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> IO (SharedTerm s)
scApply2 sc f x y = do
  g <- scApply sc f x
  scApply sc g y

scApply3 :: SharedContext s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> IO (SharedTerm s)
scApply3 sc f x y z = do
  g <- scApply2 sc f x y
  scApply sc g z

scApply4 :: SharedContext s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> SharedTerm s
         -> IO (SharedTerm s)
scApply4 sc f w x y z = do
  g <- scApply3 sc f w x y
  scApply sc g z

convertMemType :: DataLayout -> MemType -> Maybe MM.Type
convertMemType dl tp0 =
  case tp0 of
    IntType w
        | r == 0 -> return (MM.bitvectorType (fromIntegral n))
        | otherwise -> Nothing
      where (n,r) = w `divMod` 8
    PtrType{} -> return (MM.bitvectorType (dl^.ptrSize))
    FloatType -> return MM.floatType
    DoubleType -> return MM.doubleType
    ArrayType n etp -> MM.arrayType (fromIntegral n) <$> convertMemType dl etp
    VecType n etp   -> MM.arrayType (fromIntegral n) <$> convertMemType dl etp
    StructType si   -> MM.mkStruct <$> traverse fldFn (siFields si)
      where fldFn f = (,fiPadding f) <$> convertMemType dl (fiType f)

-- | Apply an operation to leaves of a mux.
applyMuxToLeaves :: (Applicative m, Monad m, Termlike t)
                 => (t -> a -> a -> m a) -- ^ Mux operation on result
                 -> (t -> m a) -- ^ Action on leaves.
                 -> t -- ^ Term to act on
                 -> m a
applyMuxToLeaves mux action = go
  where go t =
          case R.asMux t of
            Nothing -> action t
            Just (_ :*: b :*: x :*: y) -> join $ mux b <$> go x <*> go y

smLoad :: SAWBackendState t
       -> SAWMemory t
       -> MemType
       -> SharedTerm t
       -> Alignment
       -> IO (SharedTerm t, SharedTerm t) -- Validity predicate and result.
smLoad sbs m tp0 ptr0 _a0 =
  case convertMemType (sbsDataLayout sbs) tp0 of
    Just tp -> applyMuxToLeaves mux action ptr0
      where mux c = MM.tgMuxPair (smGenerator sbs) c tp
            action ptr = MM.readMem (smGenerator sbs) ptr tp (m^.memState)
    Nothing -> fail "smLoad must be given types that are even byte size."

smStore :: SAWBackendState t
        -> SAWMemory t
        -> SharedTerm t -- ^ Address to store value at.
        -> MemType      -- ^ Type of value
        -> SharedTerm t -- ^ Value to store
        -> Alignment
        -> IO (SharedTerm t, SAWMemory t) -- Predicate and new memory.
smStore sbs m p mtp v _ = do
  case convertMemType (sbsDataLayout sbs) mtp of
    Nothing -> fail "memtype given to smStore must be an even byte size."
    Just tp -> do
      let tg = smGenerator sbs
          ms = m^.memState
      if isJust (runMatcher asBvNatLit p) then
        return (MM.tgFalse tg, m)
      else do
        sz <- MM.tgConstPtr tg (MM.typeEnd 0 tp)
        c  <- MM.isAllocated tg p sz ms
        ms' <- MM.writeMem' tg p tp v ms
        return (c,m & memState .~ ms')

-- | @memcpy mem dst src len align@ copies @len@ bytes from @src@ to @dst@,
-- both of which must be aligned according to @align@ and must refer to
-- non-overlapping regions.
smCopy :: SAWBackendState t
       -> SAWMemory t
       -> SharedTerm t -- ^ Destination pointer
       -> SharedTerm t -- ^ Source pointer
       -> BitWidth  -- ^ Bitwidth for counting number of bits.
       -> SharedTerm t -- ^ Number of bytes to copy.
       -> SharedTerm t -- ^ Alignment in bytes (should have 32-bit bits)
       -> IO (SharedTerm t, SAWMemory t)
smCopy sbs m dst src w sz0 _ = do
  sz <- scResizeTerm (sbsContext sbs) w
           (ptrBitwidth (sbsDataLayout sbs), sbsPtrWidth sbs) sz0
  (c,ms) <- MM.copyMem (smGenerator sbs) dst src sz (m^.memState)
  return (c, m & memState .~ ms)

data SAWBackend t a = SAWBackend { runSAWBackend :: IO a }
  deriving (Functor)

type instance SBETerm (SAWBackend t) = SharedTerm t
type instance SBEPred (SAWBackend t) = SharedTerm t
type instance SBEMemory (SAWBackend t) = SAWMemory t

lift1 :: (x -> IO r) -> (x -> SAWBackend s r)
lift1 = (SAWBackend .)

lift2 :: (x -> y -> IO r)
      -> (x -> y -> SAWBackend s r)
lift2 = (lift1 .)

lift3 :: (x -> y -> z -> IO r)
      -> (x -> y -> z -> SAWBackend s r)
lift3 = (lift2 .)

lift4 :: (w -> x -> y -> z -> IO r)
      -> (w -> x -> y -> z -> SAWBackend s r)
lift4 = (lift3 .)

lift5 :: (v -> w -> x -> y -> z -> IO r)
      -> (v -> w -> x -> y -> z -> SAWBackend s r)
lift5 = (lift4 .)

lift6 :: (u -> v -> w -> x -> y -> z -> IO r)
      -> (u -> v -> w -> x -> y -> z -> SAWBackend s r)
lift6 = (lift5 .)

-- | Returns share term representing given state.
sbsMemType :: SAWBackendState t -> MemType -> IO (SharedTerm t)
sbsMemType sbs btp = do
  let sc = sbsContext sbs
  case btp of
    IntType w -> scIntType sc w
    FloatType  -> pure (sbsFloatType sbs)
    DoubleType -> pure (sbsDoubleType sbs)
    PtrType _  -> pure (sbsPtrType sbs)
    ArrayType n tp ->
      join $ sbsArrayTypeFn sbs <$> scNat sc (fromIntegral n)
                                <*> sbsMemType sbs tp
    VecType n tp ->
      join $ sbsVecTypeFn sbs <$> scNat sc (fromIntegral n)
                              <*> sbsMemType sbs tp
    StructType si ->
      join $ sbsStructTypeFn sbs
               <$> scNat sc (fromIntegral (siFieldCount si))
               <*> sbsFieldInfo sbs (siFields si)

-- | Returns term (tp,padding) for the given field info.
sbsFieldInfo :: SAWBackendState t
             -> V.Vector FieldInfo
             -> IO (SharedTerm t)
sbsFieldInfo sbs flds = do
    flds' <- traverse go flds
    scFieldInfo (sbsContext sbs) (sbsFieldType sbs) flds'
  where go fi = do (,fromIntegral (fiPadding fi)) <$> sbsMemType sbs (fiType fi)

-- | Returns term (tp,padding) for the given field info.
scFieldInfo :: SharedContext s
              -> SharedTerm s -- ^ Field type function
              -> V.Vector (SharedTerm s, Nat)
              -> IO (SharedTerm s)
scFieldInfo sc ftp flds = scVecLit sc ftp =<< traverse go flds
  where go (tp,p) = do
          pt <- scNat sc p
          scTuple sc [tp,pt]

scIntType :: SharedContext s -> BitWidth -> IO (SharedTerm s)
scIntType sc w = join $ scApplyLLVM_IntType sc <*> scBitwidth sc w

typedExprEvalFn :: forall t v
                 . SAWBackendState t
                -> TypedExpr v
                -> IO (ExprEvalFn v (SharedTerm t))
typedExprEvalFn sbs expr0 = do
  let dl = sbsDataLayout sbs
  let sc = sbsContext sbs
  let eval1 :: v
            -> (SharedTerm t -> IO (SharedTerm t))
            -> ExprEvalFn v (SharedTerm t)
      eval1 v fn = ExprEvalFn $ \eval -> liftIO . fn =<< eval v
  let evalBin x y op = evalBin' x y (scApply2 sc op)
      evalBin' x y f = ExprEvalFn $ \eval ->
         liftIO . uncurry f =<< both eval (x,y)
  let mkLLVMVecLit mtp v = do
        tp <- join $ scApplyLLVM_value sc <*> sbsMemType sbs mtp
        return $ ExprEvalFn $ \eval -> liftIO . scVecLit sc tp =<< traverse eval v
  let constEvalFn v = ExprEvalFn $ \_ -> return v
      -- | Apply truncation or extension ops to term.
  let extOp :: (SharedContext t
                    -> IO (SharedTerm t -> SharedTerm t
                                        -> SharedTerm t
                                        -> IO (SharedTerm t)))
            -> (SharedContext t
                    -> IO (SharedTerm t -> SharedTerm t
                                        -> SharedTerm t
                                        -> SharedTerm t
                                        -> IO (SharedTerm t)))
            -> OptVectorLength
            -> BitWidth -- ^ First constant argument to op
            -> BitWidth -- ^ Second constant width argument.
            -> v
            -> IO (ExprEvalFn v (SharedTerm t))
      extOp fn fnV mn dw rw v = do
        dt <- scBitwidth sc dw
        rt <- scBitwidth sc rw
        case fromIntegral <$> mn of
          Nothing -> do
            f <- fn sc
            return $ eval1 v (f dt rt)
          Just n  -> do
            f <- fnV sc
            nt <- scNat sc n
            return $ eval1 v (f nt dt rt)
  let resizeOp :: OptVectorLength
               -> BitWidth -- ^ Input width
               -> BitWidth -- ^ Result bitwith
               -> v
               -> IO (ExprEvalFn v (SharedTerm t))
      resizeOp mn iw rw v
        | iw < rw =
          extOp scApplyLLVM_llvmZExt  scApplyLLVM_llvmZExtV mn  (rw - iw) iw v
        | iw > rw =
          extOp scApplyLLVM_llvmTrunc scApplyLLVM_llvmTruncV mn (iw - rw) rw v
        | otherwise = return $ ExprEvalFn $ (\eval -> eval v)
  case expr0 of
    SValInteger w v  -> constEvalFn <$> scLLVMIntConst sc w v
    SValFloat  v     -> constEvalFn <$> scFloat sc v
    SValDouble v     -> constEvalFn <$> scDouble sc v
    SValNull{}       -> constEvalFn <$> scLLVMIntConst sc (ptrBitwidth dl) 0
    SValArray  mtp v -> mkLLVMVecLit mtp v
    SValVector mtp v -> mkLLVMVecLit mtp v
    SValStruct si vals -> assert (siFieldCount si == V.length vals) $ do
      sbsStructValue sbs (siFields si `V.zip` vals)
    IntArith iop mn w x y -> do
      case fromIntegral <$> mn of
        Nothing -> do
          let defOp :: (SharedContext t -> IO (SharedTerm t -> IO (SharedTerm t)))
                    -> BitWidth
                    -> IO (SharedTerm t -> SharedTerm t -> IO (SharedTerm t))
              defOp fn w' =
                fmap (scApply2 sc) $ join $ fn sc <*> scBitwidth sc w'
          evalBin' x y <$>
            case iop of
              Add{}  -> sbsAdd sbs w
              Sub{}  -> sbsSub sbs w
              Mul{}  -> defOp scApplyLLVM_llvmMul  w
              UDiv{} -> defOp scApplyLLVM_llvmUDiv w
              URem   -> defOp scApplyLLVM_llvmURem w
              SDiv{} | w > 0 -> defOp scApplyLLVM_llvmSDiv (w-1)
              SRem   | w > 0 -> defOp scApplyLLVM_llvmSRem (w-1)
              Shl{}  -> defOp scApplyLLVM_llvmShl  w
              Lshr{} -> defOp scApplyLLVM_llvmLShr w
              Ashr{} | w > 0 -> defOp scApplyLLVM_llvmAShr (w-1)
              And    -> defOp scApplyLLVM_llvmAnd  w
              Or     -> defOp scApplyLLVM_llvmOr   w
              Xor    -> defOp scApplyLLVM_llvmXor  w
              _ -> fail "Illegal arguments to intArith"
        Just n  -> do
          let defOp fn w' =
                join $ fn sc <*> scNat sc n <*> scBitwidth sc w'
          evalBin x y <$>
            case iop of
              Add{}  -> defOp scApplyLLVM_llvmAddV  w
              Sub{}  -> defOp scApplyLLVM_llvmSubV  w
              Mul{}  -> defOp scApplyLLVM_llvmMulV  w
              UDiv{} -> defOp scApplyLLVM_llvmUDivV w
              URem   -> defOp scApplyLLVM_llvmURemV w
              SDiv{} | w > 0 -> defOp scApplyLLVM_llvmSDivV (w-1)
              SRem   | w > 0 -> defOp scApplyLLVM_llvmSRemV (w-1)
              Shl{}          -> defOp scApplyLLVM_llvmShlV  w
              Lshr{}         -> defOp scApplyLLVM_llvmLShrV w
              Ashr{} | w > 0 -> defOp scApplyLLVM_llvmAShrV (w-1)
              And            -> defOp scApplyLLVM_llvmAndV  w
              Or             -> defOp scApplyLLVM_llvmOrV   w
              Xor            -> defOp scApplyLLVM_llvmXorV  w
              _ -> fail "Illegal arguments to intArith"
    PtrAdd x y ->
      return $ evalBin' x y (MM.tgAddPtr (smGenerator sbs))
    UAddWithOverflow w x y -> do
      let si = mkStructInfo dl False [IntType 1, IntType w]
      let [p0,p1] = V.toList $ fromIntegral <$> fiPadding <$> siFields si
      fmap (evalBin' x y) $
        scApplyLLVM_llvmAddWithOverflow sc
              <*> scBitwidth sc w
              <*> scNat sc p0
              <*> scNat sc p1
    ICmp op mn stp x y -> do
        -- Get scalar type bitwidth.
        let w = either id (const (ptrBitwidth dl)) stp
        case fromIntegral <$> mn of
          Nothing -> do
            let defOp mkFn w' = fmap (evalBin x y) $ join $ mkFn sc <*> scBitwidth sc w'
            case op of
              Ieq  -> defOp scApplyLLVM_llvmIeq  w
              Ine  -> defOp scApplyLLVM_llvmIne w
              Iugt -> defOp scApplyLLVM_llvmIugt w
              Iuge -> defOp scApplyLLVM_llvmIuge w
              Iult -> defOp scApplyLLVM_llvmIult w
              Iule -> defOp scApplyLLVM_llvmIule w
              Isgt | w > 0 -> defOp scApplyLLVM_llvmIsgt (w-1)
              Isge | w > 0 -> defOp scApplyLLVM_llvmIsge (w-1)
              Islt | w > 0 -> defOp scApplyLLVM_llvmIslt (w-1)
              Isle | w > 0 -> defOp scApplyLLVM_llvmIsle (w-1)
              _ -> fail "Illegal arguments to signed comparison"
          Just n  -> do
            let defOp mkFnV w' = fmap (evalBin x y) $ join $
                   mkFnV sc <*> scNat sc n
                            <*> scBitwidth sc w'
            case op of
              Ieq  -> defOp scApplyLLVM_llvmIeqV  w
              Ine  -> defOp scApplyLLVM_llvmIneV  w
              Iugt -> defOp scApplyLLVM_llvmIugtV w
              Iuge -> defOp scApplyLLVM_llvmIugeV w
              Iult -> defOp scApplyLLVM_llvmIultV w
              Iule -> defOp scApplyLLVM_llvmIuleV w
              Isgt | w > 0 -> defOp scApplyLLVM_llvmIsgtV (w-1)
              Isge | w > 0 -> defOp scApplyLLVM_llvmIsgeV (w-1)
              Islt | w > 0 -> defOp scApplyLLVM_llvmIsltV (w-1)
              Isle | w > 0 -> defOp scApplyLLVM_llvmIsleV (w-1)
              _ -> fail "Illegal arguments to signed comparison"
    Trunc mn iw v rw -> assert (iw >= rw) $
      extOp scApplyLLVM_llvmTrunc scApplyLLVM_llvmTruncV mn (iw - rw) rw v
    ZExt mn iw v rw -> assert (iw <= rw) $
      extOp scApplyLLVM_llvmZExt  scApplyLLVM_llvmZExtV  mn (rw - iw) iw v
    SExt mn iw v rw -> assert (iw <= rw) $
      extOp scApplyLLVM_llvmSExt scApplyLLVM_llvmSExtV mn (rw - iw) (iw - 1) v
    PtrToInt mn _ v rw -> resizeOp mn (ptrBitwidth dl) rw v
    IntToPtr mn iw v _ -> resizeOp mn iw (ptrBitwidth dl) v
    Select mn c tp x y -> do
      fn <- case mn of
              Nothing -> scApplyLLVM_llvmSelect sc
              Just n -> do
                fn <- scApplyLLVM_llvmSelectV sc
                fn <$> scNat sc (fromIntegral n)
      mtp <- sbsMemType sbs tp
      return $ ExprEvalFn $ \eval -> do
         join $ (\cv xv yv -> liftIO $ fn mtp cv xv yv) <$> eval c <*> eval x <*> eval y
    GetStructField si v i -> assert (i < siFieldCount si) $ do
      let n = fromIntegral (siFieldCount si)
      nt <- scNat sc n
      tps <- sbsFieldInfo sbs (siFields si)
      ft <- scFinConst sc (fromIntegral i) n
      fn <- scApplyLLVM_llvmStructElt sc
      return $ ExprEvalFn $ \eval -> (\val -> liftIO $ fn nt tps val ft) =<< eval v
    GetConstArrayElt n tp a i -> assert (i < n) $ do
      fn <- scApplyPrelude_at sc
      nt <- scNat sc (fromIntegral n)
      mtp <- sbsMemType sbs tp
      it <- scNat sc (fromIntegral i)
      return $ ExprEvalFn $ \eval -> (\val -> liftIO $ fn nt mtp val it) =<< eval a

-- | Returns value and rest out of construct.
asConsStruct :: (Monad m, Termlike t) => t -> m (t, t)
asConsStruct t = do
  ("LLVM.ConsStruct", [_, _, _, _, v, r]) <- R.asCtor t
  return (v,r)

structElt :: SharedTerm s -> Nat -> Maybe (SharedTerm s)
structElt t 0 = fst <$> asConsStruct t
structElt t i = assert (i > 0) $ do
  (_,r) <- asConsStruct t
  structElt r (i-1)

getStructElt :: Conversion (SharedTerm s)
getStructElt = Conversion $
    thenMatcher (asGlobalDef "LLVM.llvmStructElt"
                   <:> asAny
                   <:> asAny       -- Types
                   <:> asAny   -- Struct
                   <:> asFinValLit -- Index
                  )
                (\(_ :*: s :*: i) ->
                   return <$> structElt s (Prim.finVal i))

-- | Lambda abstract term @t@ over all symbolic variables.
abstract :: SAWBackendState t -> SharedTerm t -> IO (SharedTerm t)
abstract sbs t = do
  -- NB: reverse the list because sbs is stored with most recent variables first.
  ecs <- map (\(_, _, ec) -> ec) . reverse <$> readIORef (sbsVars sbs)
  scAbstractExts (sbsContext sbs) ecs t

scTermSAT :: AIG.IsAIG l g =>
  AIG.Proxy l g -> SAWBackendState t -> SharedTerm t -> IO (AIG.SatResult)
scTermSAT proxy sbs t = do
  t' <- abstract sbs t
  BB.withBitBlastedPred proxy (sbsContext sbs) t' $ \be l _domTys -> do
  AIG.checkSat be l

scWriteAiger :: AIG.IsAIG l g
             => AIG.Proxy l g
             -> SAWBackendState t
             -> FilePath
             -> [(MemType,SharedTerm t)]
             -> IO ()
scWriteAiger proxy sbs path terms = do
  let sc = sbsContext sbs
  let ts = map snd terms
  t <- scTuple sc ts
  t' <- abstract sbs t
  BB.withBitBlastedTerm proxy sc t' $ \be ls -> do
    AIG.writeAiger path (AIG.Network be (AIG.bvToList ls))

scWriteCNF :: AIG.IsAIG l g
           => AIG.Proxy l g
           -> SAWBackendState t
           -> FilePath
           -> SharedTerm t
           -> IO [Int]
scWriteCNF proxy sbs path t = do
  t' <- abstract sbs t
  BB.withBitBlastedPred proxy (sbsContext sbs) t' $ \be l _domTys -> do
  AIG.writeCNF be l path

scWriteSmtLib :: SharedContext t
              -> Bool
              -> FilePath
              -> BitWidth
              -> SharedTerm t
              -> IO ()
scWriteSmtLib sc isSmtLib2 path w t = do
  let wn = fromIntegral w
  zero <- scBvConst sc wn 0
  wt <- scNat sc wn
  t' <- scBvEq sc wt t zero
  (_, lit) <- SBVSim.sbvSolve sc [] t'
  writeFile path =<< compileToSMTLib isSmtLib2 True lit


intFromBV :: V.Vector Bool -> Integer
intFromBV v = go 0 0
  where n = V.length v
        go i r | i == n    = r
               | v V.! i   = go (i+1) $! r `setBit` i
               | otherwise = go (i+1) r

splitByWidths :: V.Vector a -> [BitWidth] -> Maybe [V.Vector a]
splitByWidths v [] | V.null v = Just []
                   | otherwise = Nothing
splitByWidths v (w:wl) = (i:) <$> splitByWidths v' wl
  where (i,v') = V.splitAt (fromIntegral w) v


scEvalTerm :: SAWBackendState t -> [Bool] -> SharedTerm t -> IO (SharedTerm t)
scEvalTerm sbs inputs t = do
  -- NB: reverse the list because sbs is stored with most recent variables first.
  (widths,varIndices,_) <- unzip3 . reverse <$> readIORef (sbsVars sbs)
  case splitByWidths (V.fromList inputs) widths of
    Nothing -> fail "Incorrect number of inputs"
    Just wv -> do
      let sc = sbsContext sbs
      -- Make list of integers contants
      vals <- zipWithM (scLLVMIntConst sc) widths (intFromBV <$> wv)
      -- Create map of variable indices to integers.
      let m = Map.fromList (varIndices `zip` vals)
      -- Return instantiated t.
      scInstantiateExt sc m t

scTermMemPrettyPrinter :: MM.MemPrettyPrinter (SharedTerm s) (SharedTerm s) (SharedTerm s)
scTermMemPrettyPrinter = pp
  where ppt _ = scPrettyTermDoc
        pp = MM.PP { MM.ppPtr = ppt
                   , MM.ppCond = ppt
                   , MM.ppTerm = ppt
                   }


-- | Create a SAW backend.
createSAWBackend :: AIG.IsAIG l g
                 => AIG.Proxy l g
                 -> DataLayout
                 -> IO (SBE (SAWBackend t), SAWMemory t)
createSAWBackend proxy dl = do
  sc0 <- mkSharedContext llvmModule
  (sbe, mem, _) <- createSAWBackend' proxy dl sc0
  return (sbe, mem)

createSAWBackend' :: AIG.IsAIG l g
                  => AIG.Proxy l g
                  -> DataLayout
                  -> SharedContext t
                  -> IO (SBE (SAWBackend t), SAWMemory t, SharedContext t)
createSAWBackend' proxy dl sc0 = do
  let activeDefs = filter defPred $ allModuleDefs llvmModule
        where defPred d = defIdent d `Set.notMember` excludedDefs
              excludedDefs = Set.fromList
                [ "Prelude.append"
                , "Prelude.bvAdd"
                , "Prelude.bvAddWithCarry"
                , "Prelude.bvSub"
                , "Prelude.bvMul"
                , "Prelude.bvUDiv"
                , "Prelude.bvURem"
                , "Prelude.bvSDiv"
                , "Prelude.bvSRem"
                , "Prelude.bvShl"
                , "Prelude.bvShr"
                , "Prelude.bvSShr"
                , "Prelude.bvNot"
                , "Prelude.bvAnd"
                , "Prelude.bvOr"
                , "Prelude.bvXor"
                , "Prelude.bvMbit"
                , "Prelude.bvEq"
                , "Prelude.bvugt"
                , "Prelude.bvuge"
                , "Prelude.bvult"
                , "Prelude.bvule"
                , "Prelude.bvsgt"
                , "Prelude.bvsge"
                , "Prelude.bvslt"
                , "Prelude.bvsle"
                , "Prelude.bvTrunc"
                , "Prelude.bvUExt"
                , "Prelude.bvSExt"
                , "Prelude.vTake"
                , "Prelude.vDrop"
                ]
  let eqs = [ "Prelude.ite_not"
            , "Prelude.ite_fold_not"
            , "Prelude.ite_nest1"
            , "Prelude.ite_nest2"
            , "Prelude.vTake0"
            , "Prelude.vDrop0"
            , "Prelude.bveq_sameL"
            , "Prelude.bveq_sameR"
            , "Prelude.bveq_same2"
            , "LLVM.ite_same"
            , "LLVM.ite_false_false"
            , "LLVM.and_true2"
            , "LLVM.bvEq_commute_ite1"
            , "LLVM.bvule_sameL"
            , "LLVM.bvule_sameR"
            , "LLVM.bvule_same2"
            ]
  let conversions =
        natConversions
        ++ bvConversions
        ++ vecConversions
        ++ [ remove_ident_coerce
           , remove_ident_unsafeCoerce]
        ++ [ getStructElt
           ]
  simpSet <- scSimpset sc0 activeDefs eqs conversions
  let sc = rewritingSharedContext sc0 simpSet
  sbs <- mkBackendState dl sc

  boolType <- scPrelude_Bool sc
  trueTerm <- scApplyPrelude_True sc
  pNot <- scApplyPrelude_not sc
  pAnd <- scApplyPrelude_and sc
  iteFn <- scApplyPrelude_ite sc

  apply_bvEq <- scApplyLLVM_llvmIeqBool sc

  valueFn   <- scApplyLLVM_value sc
  intTypeFn <- scApplyLLVM_IntType sc

  let sbe = SBE { sbeTruePred = trueTerm
                , applyIEq = \w x y -> SAWBackend $ do
                   join $ apply_bvEq <$> scBitwidth sc w ?? x ?? y
                , applyAnd  = lift2 pAnd
                , applyBNot = lift1 pNot
                , applyPredIte = lift3 (iteFn boolType)
                , applyIte = \tp x y z -> SAWBackend $ do
                    tpt <- join $ scApplyLLVM_value sc <*> sbsMemType sbs tp
                    Right <$> iteFn tpt x y z
                , LLVM.asBool = R.asBool
                , prettyPredD = scPrettyTermDoc
                , evalPred = \inputs t -> SAWBackend $ do
                    t' <- scEvalTerm sbs inputs t
                    case R.asBool t' of
                      Just b -> return b
                      Nothing ->
                        fail $ "Could not evaluate predicate as Boolean:\n" ++ show t'
                , freshInt = \w -> SAWBackend $ do
                    vtp <- valueFn =<< intTypeFn =<< scBitwidth sc w
                    i <- scFreshGlobalVar sc
                    let ec = EC i "_" vtp
                    t <- scFlatTermF sc (ExtCns ec)
                    modifyIORef' (sbsVars sbs) ((w,i,ec):)
                    return t
                , typedExprEval = typedExprEvalFn sbs
                , applyTypedExpr = \expr -> SAWBackend $ do
                    ExprEvalFn fn <- typedExprEvalFn sbs expr
                    fn return
                , prettyTermD = scPrettyTermDoc
                , asUnsignedInteger = asUnsignedBitvector
                , asSignedInteger   = asSignedBitvector
                , asConcretePtr     = asUnsignedBitvector (ptrBitwidth dl)
                , memDump      = \m _ -> SAWBackend $ do
                    print $ MM.ppMem scTermMemPrettyPrinter (m^.memState)
                , memLoad      = lift4 (smLoad sbs)
                , memStore     = lift5 (smStore sbs)
                , memCopy      = lift6 (smCopy sbs)
                , memAddDefine = lift3 (smAddDefine dl sc)
                , memInitGlobal =  \m mtp v -> SAWBackend $ do
                   case convertMemType (sbsDataLayout sbs) mtp of
                     Nothing -> fail "memtype given to smStore must be an even byte size."
                     Just tp -> do
                       ptr <- allocPtr sbs
                       let tg = smGenerator sbs
                       Just . (ptr,) <$> memState (MM.allocAndWriteMem tg MM.HeapAlloc ptr tp v) m
                , codeLookupSymbol = ((SAWBackend . return) .) . smLookupSymbol

                , stackAlloc     = lift5 (smAlloc sbs MM.StackAlloc)
                , heapAlloc      = lift5 (smAlloc sbs MM.HeapAlloc)

                , stackPushFrame = SAWBackend . return . (trueTerm,)
                                   . over memState MM.pushStackFrameMem
                , stackPopFrame  = SAWBackend . return . (memState %~ MM.popStackFrameMem)
                , memBranch      = SAWBackend . return . (memState %~ MM.branchMem)
                , memBranchAbort = SAWBackend . return . (memState %~ MM.branchAbortMem)
                , memMerge = \c x y -> SAWBackend $ return $ smMerge c x y

                , termSAT    = lift1 (scTermSAT proxy sbs)
                , writeAiger = lift2 (scWriteAiger proxy sbs)
                , writeCnf   = Just (lift2 (scWriteCNF proxy sbs))

                , writeSAWCore = Just $ \nm t -> SAWBackend $ do
                    writeFile nm (scWriteExternal t)
                , writeSmtLib = Just (lift4 (scWriteSmtLib sc))

                , evalAiger  = \inputs _ t -> SAWBackend $ scEvalTerm sbs inputs t
                , sbeRunIO   = runSAWBackend
                }
  return (sbe, emptySAWMemory, sc0)

_unused :: a
_unused = undefined
  scLLVM_LLVMType
  scLLVM_StructValue
  scApplyLLVM_arithmeticWithOverflowResult
  scApplyLLVM_binFn
  scApplyLLVM_binRel
  scApplyLLVM_consFieldType
  scApplyLLVM_emptyFields
  scApplyLLVM_singleField
  scApplyLLVM_sbvVecZipWith
  scApplyLLVM_mkOverflowResult
  scApplyLLVM_liftVecBVRel
  scApplyLLVM_binVRel
  scApplyLLVM_bvMap
  scApplyLLVM_bvVecZipWith
  scApplyLLVM_liftBVRel
  scApplyLLVM_and_true2
  scApplyLLVM_bvEq_commute_ite1
  scApplyLLVM_bvule_same2
  scApplyLLVM_bvule_sameL
  scApplyLLVM_bvule_sameR
  scApplyLLVM_ite_false_false
  scApplyLLVM_ite_same
  scApplyLLVM_mkArrayType
  scApplyLLVM_mkDoubleType
  scApplyLLVM_mkFloatType
  scApplyLLVM_mkIntType
  scApplyLLVM_mkPtrType
